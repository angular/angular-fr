block includes
  include ../_util-fns
  - var _library_module = 'library module'
  - var _at_angular = '@angular'

:marked
  Angular 2 is a framework to help us build client applications in HTML and
  either JavaScript or a language (like Dart or TypeScript) that compiles to JavaScript.

  Angular 2 est un framework qui nous aide à construire des applications en HTML et
  en JavaScript ou n'importe quel langage (comme Dart ou TypeScript) qui compile en JavaScript.

block angular-parts
  :marked
    The framework consists of several cooperating libraries, some of them core and some optional.

    Le framework consiste en un ensemble de libraires coopératives, certaines principales, d'autres optionnelles.

:marked
  With Angular, we write applications by composing HTML *templates* with Angularized-markup,
  writing *component* classes to manage those templates, adding application logic in *services*,
  and handing the top root component to Angular's *bootstrapper*.

  Avec Angular, nous écrivons des applications en composant des *templates* HTML avec des balises "angularisées",
  nous créons des classes de *composants* pour gérer ces templates, nous ajoutons la logique applicative dans des *services*
  et nous fournissons un composant racine pour initialiser le tout.

  Angular takes over, presenting our application content in a browser and
  responding to user interactions according to the instructions we provided.

  Angular prend alors le relais, pour afficher notre application dans le navigateur et
  répondre aux interactions de l'utilisateur à l'aide des instructions que nous lui avons fournies.

  Of course there is more to it than this.
  We'll learn the details when we dive into the guide chapters.
  Let's get the big picture first.

  Bien sûr c'est un peu simplifié.
  Nous verrons tout cela en détails au fur et à mesure que nous avancerons dans les chapitres.
  Mais essayons d'abord d'avoir une vision d'ensemble.

figure
  img(src="/resources/images/devguide/architecture/overview2.png" alt="overview" style="margin-left:-40px;" width="700")

:marked
  The architecture diagram identifies the eight main building blocks of an Angular 2 application:

  Ce diagramme d'architecture identifie les huit composants principaux d'une application Angular 2&nbsp;:

  1. [Modules](#modules)
  1. [Les modules](#modules)

  1. [Components](#components)
  1. [Les composants](#components)

  1. [Templates](#templates)
  1. [Les templates](#templates)

  1. [Metadata](#metadata)
  1. [Les métadonnées](#metadata)

  1. [Data binding](#data-binding)
  1. [La liaison de données](#data-binding)

  1. [Directives](#directives)
  1. [Les directives](#directives)

  1. [Services](#services)
  1. [Les services](#services)

  1. [Dependency injection](#dependency-injection)
  1. [L'injection de dépendances](#dependency-injection)

  Learn these, and we're on our way.

  Apprenons en plus sur tout cela et nous serons sur la bonne voie.
.l-sub-section
  p The code referenced in this chapter is available as a #[+liveExampleLink2()].

.l-main-section
:marked
  ## Modules
figure
  img(src="/resources/images/devguide/architecture/module.png" alt="Component" align="left" style="width:240px; margin-left:-40px;margin-right:10px" )
:marked
  Angular apps are modular.

  Les applications Angular sont modulaires.

  In general we assemble our application from many **modules**.

  En général nous assemblons notre application à partir de plusieurs **modules**.

  A typical module is a cohesive block of code dedicated to a single purpose.
  A module **exports** something of value in that code, typically one thing such as a class.

  Un module typique est un ensemble de code cohérent dédié à un unique objectif.
  Un module **exporte** quelque chose à partir de ce code, comme typiquement une classe.
  <br clear="all"><br>

block modules-in-dart
  //- N/A

block modules-are-optional
  .l-sub-section
    :marked
      ### Modules are optional

      ### Les modules sont optionnels

      We highly recommend modular design. TypeScript has great support for ES2015 module syntax and our chapters assume we're taking a modular
      approach using that syntax. That's why we list *Module* among the basic building blocks.

      Nous vous conseillons fortement d'utiliser un découpage modulaire. TypeScript supporte très bien la syntaxe des modules ES2015 et dans nos chapitres, nous partons du principe que nous utilisons
      une approche modulaire avec cette syntaxe. C'est pour cela que nous avons ajouté le *Module* comme composant de base.

      Angular itself doesn't require a modular approach nor this particular syntax. Don't use it if you don't want it.
      Each chapter has plenty to offer after you steer clear of the `import` and `export` statements.

      Angular en soi ne nécessite ni découpage modulaire ni cette syntaxe en particulier. Ne l'utilisez pas si vous ne le souhaitez pas.
      Chaque chapitre a beaucoup à offrir, une fois passées les déclarations d'`import` et d'`export`

      Find setup and organization clues in the JavaScript track (select it from the combo-box at the top of this page)
      which demonstrates Angular 2 development with plain old JavaScript and no module system.

      Vous trouverez des conseils d'installation et d'utilisation dans la section JavaScript (vous y accédez par le menu déroulant en haut de la page)
      qui vous montreront comment développer une application Angular 2 en JavaScript traditionnel sans système de module.

- var _app_comp_filename = _docsFor == 'dart' ? 'app_component.dart' : 'app.component.ts';
:marked
  Perhaps the first module we meet is a module that exports a *component* class.
  The component is one of the basic Angular blocks, we write a lot of them,
  and we'll talk about components in the next segment. For the moment it is enough to know that a
  component class is the kind of thing we'd export from a module.


  Notre premier module sera peut-être un module qui exporte une classe de *composant*.
  Le composant est un des éléments de base d'Angular, nous en écrirons beaucoup
  et nous parlerons d'eux dans la prochaine section. Pour le moment, il vous suffit de savoir
  qu'une classe de composant est le type d'élément que nous exporterons à partir d'un module

  Most applications have an `AppComponent`. By convention, we'll find it in a file named `!{_app_comp_filename}`.
  Look inside such a file and we'll see a declaration such as this one.

  La plupart des applications ont un  `AppComponent`. Par conventions, nous le trouvons dans un fichier appelé `!{_app_comp_filename}`.
  Regardons dans ce fichier et nous trouverons une déclaration de ce type&nbsp;:

+makeExcerpt('app/app.component.ts ()', 'export')

block export-qualifier
  :marked
    The `export` statement tells TypeScript that this is a module whose
    `AppComponent` class is public and accessible to other modules of the application.

    La déclaration `export` indique à TypeScript qu'il s'agit d'un module dans lequel
    la classe `AppComponent` est publique et accessible à d'autres modules de l'application.

:marked
  When we need a reference to the `AppComponent`, we **import** it like this:

  Lorsque nous avons besoin d'une référence au `AppComponent`, nous l'**importons** comme cela&nbsp;:

+makeExcerpt('app/main.ts', 'import')

block ts-import
  :marked
    The `import` statement tells the system it can get an `AppComponent` from a module named `app.component`
    located in a neighboring file.
    The **module name** (AKA module id) is often the same as the filename without its extension.

    La déclaration `import` indique au système qu'il peut récupérer un `AppComponent` dans un module appelé `app.component`
    localisé dans un fichier voisin.
    Le **nom du module** (ou l'id du module) correspond souvent au nom du fichier sans l'extension.

:marked
  ### Libraries

figure
  img(src="/resources/images/devguide/architecture/library-module.png" alt="Component" align="left" style="width:240px; margin-left:-40px;margin-right:10px" )

block angular-library-modules
  :marked
    Some modules are _libraries_ of other modules.
    Angular itself ships as a collection of library modules within several npm packages.
    Their names begin with the `!{_at_angular}` prefix.

    Certains modules sont des _librairies_ contenant d'autres modules.
    Angular lui même est constitué d'une collection de librairies de modules dispersés dans plusieurs paquets npm.
    Leurs noms commencent toujours par le préfixe`!{_at_angular}`.

    Each Angular library contains a [barrel](../glossary.html#barrel) module
    that is actually a public façade over several logically-related private modules.

    Chaque librairie Angular contient un module [baril](../glossary.html#barrel)
    qui est en fait une façade publique vers plusieurs modules privés partageant une même logique.

:marked
  `!{_at_angular}/core` is the primary Angular library from which we get most of what we need.

  `!{_at_angular}/core` est la librairie principale d'Angular à partir de laquelle nous récupérons la plupart des éléments dont nous avons besoin.
  <br clear="all">

  There are other important Angular libraries too, such as `!{_at_angular}/common`<span if-docs="ts">,
  `!{_at_angular}/http`</span> and `!{_at_angular}/router`.
  We import what we need from an Angular !{_library_module}.

  Il y a d'autres librairies importantes dans Angular, comme `!{_at_angular}/common`<span if-docs="ts">,
  `!{_at_angular}/http`</span> et `!{_at_angular}/router`.
  Nous importons ce dont nous avons besoin à partir des librairies de modules d'Angular.

block angular-imports
  :marked
    For example, we import the Angular **`Component` *function*** from `@angular/core` like this:

    Par exemple, nous importons la ** *fonction* `Component`** à partir d' `@angular/core` comme cela:
  +makeExcerpt('app/app.component.ts', 'import')
  :marked
    Compare that syntax to our previous import of `AppComponent`.

    Comparez cette syntaxe à l'import de l'`AppComponent` vu précédemment.
  +makeExcerpt('app/main.ts', 'import')

  :marked
    Notice the difference?
    In the first case, when importing from an Angular library module,
    the import statement refers to the bare module name, `@angular/core`, *without a path prefix*.

    Vous voyez la différence?
    Dans le premier cas, lorsque nous importons à partir d'une librairie de modules Angular,
    la déclaration d'import fait référence au nom du module baril, `@angular/core`, *sans préfixe de chemin*.

    When we import from one of *our* own files, we prefix the module name with the file path.
    In this example we specify  a relative file path (`./`). That means the
    source module is in the same folder (`./`) as the module importing it.
    We could path up and around the application folder structure if the source module were somewhere else.

    Lorsque nous importons à partir d'un de *nos* propres fichiers, nous préfixons le nom du module avec le chemin d'accès au fichier.
    Dans cet exemple nous spécifions un chemin relatif (`./`). Cela signifie que
    notre module ciblé est dans le même répertoire (`./`) que le module qui souhaite l'importer.
    Nous pouvons utiliser l'arborescence de répertoires de notre application si le module ciblé est situé ailleurs.
  .l-sub-section
    :marked
      We import and export in the ECMAScript 2015 (ES2015) module syntax.
      Learn more about that syntax [here](http://www.2ality.com/2014/09/es6-modules-final.html)
      and many other places on the web.

      Nous importons et exportons en utilisant la syntaxe des modules d'ECMAScript 2015 (ES2015).
      Apprenez en plus sur cette syntaxe [ici](http://www.2ality.com/2014/09/es6-modules-final.html)
      et à beaucoup d'autres endroits sur le web.

      The infrastructure *behind* module loading and importing is an important subject.
      But it's a subject outside the scope of this introduction to Angular.
      While we're focused on our application, *import* and *export*
      is about all we need to know.

      L'infrastructure *cachée derrière* l'import et l'export de module est un sujet important.
      Mais il sort du contexte de notre introduction à Angular.
      Restons concentré sur notre application, les déclarations  *import* et *export*
      sont tous ce que vous avez besoin de savoir.

- var _export = _docsFor == 'dart' ? 'publicly declare' : 'export';
- var _declare = _docsFor == 'dart' ? 'declare' : 'export';
:marked
  The key take-aways are:

  Les principes clés sont:

  * Angular apps are composed of modules.

  * Les applications Angular sont composées de modules.

  * Modules !{_export} things &mdash; classes, function, values &mdash; that other modules import.

  * Les modules exportent quelque chose &mdash; des classes, des fonctions, des valeurs &mdash; que d'autres modules importent.

  * We prefer to write our application as a collection of modules, each module exporting one thing.

  * Nous préférons écrire notre application comme une collection de modules, chacun exportant quelque chose.

  The first module we write will most likely !{_declare} a component.

  Notre premier module déclarera probablement un composant.

.l-main-section
:marked
  ## Components

  ## Les composants
figure
  img(src="/resources/images/devguide/architecture/hero-component.png" alt="Component" align="left" style="width:200px; margin-left:-40px;margin-right:10px" )

:marked
  A **component** controls a patch of screen real estate that we could call a *view*.
  The shell at the application root with navigation links, a list of heroes, a hero editor ...
  they're all views controlled by components.

  Un **composant** contrôle un ensemble d'éléments de la page que nous pourrons appeler *vue*.
  Le squelette de l'application avec les liens de navigations, une liste de héros, un éditeur de héros ...
  ce sont tous des vues contrôlées par des composants.

  We define a component's application logic &mdash; what it does to support the view &mdash; inside a class.
  The class interacts with the view through an API of properties and methods.

  Nous définissons la logique applicative de notre composant &mdash; ce qu'il fait pour aider la vue &mdash; dans une classe.
  La classe interagit avec la vue à l'aide d'une API de propriétés et de méthodes.

  <a id="component-code"></a>
  A `HeroListComponent`, for example, might have a `heroes` property that returns !{_an} !{_array} of heroes
  that it acquired from a service.
  It might have a `selectHero()` method that sets a `selectedHero` property when the user clicks to choose a hero from that list.
  The component might be a class like this:

  Par exemple, un `HeroListComponent` pourrait avoir une propriété `heroes` qui retourne un tableau de héros
  qui provient d'un service.
  Il pourrait avoir une méthode `selectHero()` qui définit la propriété `selectedHero` lorsqu'un utilisateur clique sur un héros de la liste.
  Ce composant pourrait être une classe écrite comme indiqué ci-dessous&nbsp;:

+makeExcerpt('app/hero-list.component.ts', 'class')
:marked
  Angular creates, updates, and destroys components as the user moves through the application.
  The developer can take action at each moment in this lifecycle through optional [lifecycle hooks](lifecycle-hooks.html), like `ngOnInit()` declared above.

  Angular crée, modifie et détruit les composants au fur et  à mesure que l'utilisateur navigue dans l'application.
  Le développeur peut interagir à tout moment à l'aide des [méthodes du cycle de vie](lifecycle-hooks.html), comme `ngOnInit()` déclarée ci-dessus.
.l-sub-section
  :marked
    We may wonder who is calling the component's constructor? Who provides the service parameter?
    For the moment, have faith that Angular will call the constructor and deliver an
    appropriate `HeroService` when we need it.

    Nous pouvons nous demander qui appelle le constructeur du composant ? Qui fournit le service en paramètre ?
    Pour le moment, ayez confiance, Angular appellera le constructeur et lui passera
    un `HeroService` approprié le moment voulu.

.l-main-section
:marked
  ## Templates
figure
  img(src="/resources/images/devguide/architecture/template.png" alt="Template" align="left" style="width:200px; margin-left:-40px;margin-right:10px" )
:marked
  We define a component's view with its companion **template**. A template is a form of HTML
  that tells Angular how to render the component.

  Nous définissons la vue d'un composant à l'aide de son compagnon le **template**. Un template est un type de HTML
  qui indique à Angular comment afficher le composant.

  A template looks like regular HTML much of the time ... and then it gets a bit strange. Here is a
  template for our `HeroListComponent`:

  Un template ressemble à du HTML traditionnel la plupart du temps ... et parfois il devient un peu étrange. Retrouvez ci-dessous
  le template de notre `HeroListComponent`&nbsp;:

+makeExample('app/hero-list.component.html')

:marked
  This template features typical HTML elements like `<h2>` and  `<p>`.
  But what are `*ngFor`, `{{hero.name}}`, `(click)`, `[hero]`, and `<hero-detail>`?

  Ce template utilise des éléments HTML typiques comme `<h2>` et  `<p>`.
  Mais que représentent ces `*ngFor`, `{{hero.name}}`, `(click)`, `[hero]`, et `<hero-detail>`?

  These are examples of Angular's [template syntax](template-syntax.html).
  We will grow accustomed to that syntax and may even learn to love it.
  We'll begin to explain it in a moment.

  Ce sont des exemples de la [syntaxe de template](template-syntax.html) d'Angular.
  Nous allons progressivement nous familiariser avec cette syntaxe et peut être même commencer à l'aimer.
  Nous allons vous expliquer tout cela dans un moment.

  Before we do, focus attention on the last line.
  The `<hero-detail>` tag is a custom element representing the `HeroDetailComponent`.

  Mais avant cela, regardez la dernière ligne.
  La balise `<hero-detail>` est un élément personnalisé qui représente un `HeroDetailComponent`.

  The `HeroDetailComponent` is a *different* component than the `HeroListComponent` we've been reviewing.
  The `HeroDetailComponent` (code not shown) presents facts about a particular hero, the
  hero that the user selects from the list presented by the `HeroListComponent`.
  The `HeroDetailComponent` is a **child** of the `HeroListComponent`.

  Le `HeroDetailComponent` est un composant *différent* du `HeroListComponent` vu précédemment.
  Le `HeroDetailComponent` (le code n'est pas indiqué) affiche les propriétés d'un héros en particulier, celui
  que l'utilisateur a sélectionné dans la liste du `HeroListComponent`.
  Le `HeroDetailComponent` est un **enfant** du `HeroListComponent`.

figure
  img(src="/resources/images/devguide/architecture/component-tree.png" alt="Metadata" align="left" style="width:300px; margin-left:-40px;margin-right:10px" )
:marked
  Notice how `<hero-detail>` rests comfortably among native HTML elements.
  We can and _will_ mix our custom components with native HTML in the same layouts.

  Observez comme le `<hero-detail>` est confortablement installé au milieu d'éléments HTML natifs.
  Nous pourrons et devrons mélanger nos composants personnalisés avec des éléments natifs HTML dans la même vue.

  In this manner we'll compose complex component trees to build out our richly featured application.

  De cette façon, nous composerons un arbre de composants complexe pour construire les fonctionnalités de notre application.

<br clear="all">

.l-main-section
:marked
  ## Metadata

  ## Les métadonnées
figure
  img(src="/resources/images/devguide/architecture/metadata.png" alt="Metadata" align="left" style="width:150px; margin-left:-40px;margin-right:10px" )

:marked
<p style="padding-top:10px">Metadata tells Angular how to process a class.</p>

<p style="padding-top:10px">Les métadonnées indiquent à Angular comment utiliser une classe.</p>
<br clear="all">
:marked
  [Looking back at the code](#component-code) for `HeroListComponent`, we see that it's just a class.
  There is no evidence of a framework, no "Angular" in it at all.

  [Si nous revenons au code](#component-code) du `HeroListComponent`, nous constatons qu'il ne s'agit que d'une classe.
  il n'y a pas de traces de framework ou d'Angular.

  In fact, it really is *just a class*. It's not a component until we *tell Angular about it*.

  En fait, c'est vraiment *juste une classe*. Ce n'est pas un composant tant que nous ne *l'avons pas indiqué à Angular*.

  We tell Angular that `HeroListComponent` is a component by attaching **metadata** to the class.

  Nous informons Angular que le `HeroListComponent` est un composant en attachant à sa classe des **métadonnées**.

  In !{_Lang}, we attach metadata by using !{_a} **!{_decorator}**.
  Here's some metadata for `HeroListComponent`:

  En !{_Lang}, nous attachons les métadonnées en utilisant un **décorateur**.
  Retrouvez ci-dessous quelques métadonnées du `HeroListComponent`&nbsp;:

+makeExcerpt('app/hero-list.component.ts', 'metadata')

:marked
  Here we see the `@Component` !{_decorator} which (no surprise) identifies the class
  immediately below it as a component class.

  Ici nous voyons le décorateur `@Component`  qui (sans surprise) identifie la classe
  immédiatement définie en dessous comme étant une classe de composant.

block ts-decorator
  :marked
    A decorator is a function. Decorators often have a configuration parameter.
    The `@Component` decorator takes a required configuration object with the
    information Angular needs to create and present the component and its view.

    Un décorateur est une fonction. Les décorateurs ont souvent leur configuration passée en paramètre.
    Le décorateur `@Component` prend en paramètre un objet de configuration obligatoire
    qui contient les informations dont Angular a besoin pour créer et afficher le composant et sa vue.

    Here are a few of the possible `@Component` configuration options:

    Voici un aperçu des différentes options de configuration du décorateur `@Component`&nbsp;:

:marked
  - `selector`: CSS selector that tells Angular to create and insert an instance of this component
  where it finds a `<hero-list>` tag in *parent* HTML.
  For example, if an app's  HTML contains `<hero-list></hero-list>`, then
  Angular inserts an instance of the `HeroListComponent` view between those tags.

  - `selector`: sélecteur CSS qui indique à Angular de créer et insérer une instance de ce composant
  lorsqu'il trouve une balise `<hero-list>` dans le HTML *parent*.
  Par exemple, si le HTML d'une application contient `<hero-list></hero-list>`, alors
  Angular insert une instance de la vue du `HeroListComponent` entre ces balises.

  - `templateUrl`: address of this component's template, which we showed [above](#templates).

  - `templateUrl`: chemin vers le template du composant dont nous parlions [précédemment](#templates).

  - `directives`: !{_array} of the components or directives that *this* template requires.
  We saw in the last line of our template that we expect Angular to insert a `HeroDetailComponent`
  in the space indicated by `<hero-detail>` tags.
  Angular will do so only if we mention the `HeroDetailComponent` in this `directives` !{_array}.

  - `directives`: tableau de composants ou de directives que *ce* template nécessite.
  Nous avons vu dans la dernière ligne de notre template, que nous nous attendions à ce qu'Angular insère un `HeroDetailComponent`
  à l'endroit localisé par les balises `<hero-detail>`.
  Angular s'éxécutera uniquement si nous faisons mention du `HeroDetailComponent` dans ce tableau de `directives`.

  - `providers`: !{_array} of **dependency injection providers** for services that the component requires.
  This is one way to tell Angular that our component's constructor requires a `HeroService`
  so it can get the list of heroes to display. We'll get to dependency injection later.

  - `providers`: tableau de  **fournisseurs d'injection de dépendances** pour les services dont le composant a besoin.
  Il s'agit d'une façon d'indiquer à Angular que le constructeur de notre composant nécessite un `HeroService`
  pour obtenir la liste des héros à afficher. Nous reviendrons sur l'injection de dépendances plus tard.

figure
  img(src="/resources/images/devguide/architecture/template-metadata-component.png" alt="Metadata" align="left" style="height:200px; margin-left:-40px;margin-right:10px" )

:marked
  Angular reads the metadata specified by the `@Component`
  annotation. That's how Angular learns to do "the right thing".

  Angular lit les métadonnées spécifiées par l'annotation `@Component`.
  C'est ainsi qu'Angular apprend à "faire les choses bien".

  The template, metadata, and component together describe a view.

  Le template, les métadonnées et le composant forment ensemble ce que l'on appelle la vue.

  We apply other metadata !{_decorator}s in a similar fashion to guide Angular behavior.
  `@Injectable`, `@Input`, and `@Output` are a few of the more popular !{_decorator}s
  we'll master as our Angular knowledge grows.

  Nous utiliserons d'autres décorateurs de la même façon pour guider le comportement d'Angular.
  `@Injectable`, `@Input`, et `@Output` sont quelques décorateurs parmi les plus utilisés
  que nous allons apprendre à maitriser au fur et à mesure de notre progression.
<br clear="all">
:marked
  The architectural takeaway is that we must add metadata to our code
  so that Angular knows what to do.

  Ce qu'il faut retenir, c'est que nous aurons besoin d'ajouter des métadonnées à notre code
  pour qu'Angular sache quoi faire.
.l-main-section
:marked
  ## Data binding

  ## La liaison de données

  Without a framework, we would be responsible for pushing data values into the HTML controls and turning user responses
  into actions and value updates. Writing such push/pull logic by hand is tedious, error-prone, and a nightmare to
  read as any experienced jQuery programmer can attest.

  Sans framework, nous aurions à insérer les données dans les champs HTML et répondre à l'utilisateur
  par des actions et des mises à jour. Ecrire ce type de code à la main est fastidieux, susceptible d'engendrer des erreurs et devient rapidement
  un cauchemar à lire comme beaucoup de développeurs jQuery expérimentés peuvent en attester.
figure
  img(src="/resources/images/devguide/architecture/databinding.png" alt="Data Binding" style="width:220px; float:left; margin-left:-40px;margin-right:20px" )
:marked
  Angular supports **data binding**,
  a mechanism for coordinating parts of a template with parts of a component.
  We add binding markup to the template HTML to tell Angular how to connect both sides.

  Angular utilise la **liaison de données**,
  un mécanisme qui permet de coordonner une partie du template avec une partie du composant.
  Nous ajoutons des éléments de liaisons au template HTML pour permettre à Angular de faire le lien entre les deux.

  There are four forms of data binding syntax. Each form has a direction &mdash; to the DOM, from the DOM, or in both directions &mdash;
  as indicated by the arrows in the diagram.

  Il y a quatre types de syntaxe de liaisons. Chaque forme a une direction &mdash; vers le DOM, du DOM ou dans les deux directions &mdash;
  comme indiquées par des flèches sur le diagramme suivant.
<br clear="all">
:marked
  We saw three forms of data binding in our [example](#templates) template:

  Nous avons trois formes de liaison dans notre [exemple](#templates) de template:

+makeExcerpt('app/hero-list.component.1.html', 'binding')

:marked
  * The `{{hero.name}}` [*interpolation*](displaying-data.html#interpolation)
  displays the component's `hero.name` property value within the `<li>` tags.

  * [*L'interpolation*](displaying-data.html#interpolation) `{{hero.name}}`
  affiche la propriété `hero.name` du composant dans les balises `<li>`.

  * The `[hero]` [*property binding*](template-syntax.html#property-binding) passes the value of `selectedHero` from
  the parent `HeroListComponent` to the `hero` property of the child `HeroDetailComponent`.

  * La [*liaison par propriété*](template-syntax.html#property-binding) `[hero]`  passe la valeur `selectedHero` du
  parent `HeroListComponent` à la propriété `hero` de l'enfant `HeroDetailComponent`.

  * The `(click)` [*event binding*](user-input.html#click) calls the component's `selectHero` method when the user clicks a hero's name.

  * La [*liaison par événement*](user-input.html#click)`(click)` appelle la méthode `selectHero` du composant lorsque l'utilisateur clique sur le nom d'un héros.

  **Two-way data binding** is an important fourth form
  that combines property and event binding in a single notation, using the `ngModel` directive.
  We didn't have a two-way binding in the `HeroListComponent` template;
  here's an example from the `HeroDetailComponent` template:

  La **liaison bidirectionnelle** est une quatrième forme
  qui combine les liaisons par propriété et par évènement en une seule notation, en utilisant la directive `ngModel`.
  Nous n'avons pas de liaison bidirectionnelle dans le template du `HeroListComponent`.
  Voici un exemple extrait du template du `HeroDetailComponent`&nbsp;:

+makeExcerpt('app/hero-detail.component.html', 'ngModel')

:marked
  In two-way binding, a data property value flows to the input box from the component as with property binding.
  The user's changes also flow back to the component, resetting the property to the latest value,
  as with event binding.

  Dans la liaison bidirectionnelle, la valeur d'une propriété de donnée transite du composant vers le champ de saisie comme dans le cas de la liaison de propriété.
  Les changements utilisateurs transitent également vers le composant, enregistrant dans la propriété la dernière valeur saisie
  comme dans une liaison par événement.

  Angular processes *all* data bindings once per JavaScript event cycle,
  from the root of the application component tree down to the leaves.

  Angular traite *toutes* les liaisons de données une seule fois par cycle d'événements JavaScript,
  en partant du composant applicatif de plus haut niveau et en parcourant l'arbre de composants vers les enfants.

figure
  img(src="/resources/images/devguide/architecture/component-databinding.png" alt="Data Binding" style="float:left; width:300px; margin-left:-40px;margin-right:10px" )
:marked
  We don't know all the details yet,
  but it's clear from these examples that data binding plays an important role in communication
  between a template and its component.

  Nous n'avons pas encore tous les détails,
  mais il ressort clairement de ces exemples que la liaison de données joue un rôle important dans la communication
  entre un template et son composant.
<br clear="all">
figure
  img(src="/resources/images/devguide/architecture/parent-child-binding.png" alt="Parent/Child binding" style="float:left; width:300px; margin-left:-40px;margin-right:10px" )
:marked
  Data binding is also important for communication between parent and child components.

  La liaison de donnée est également importante pour la communication entre un composant parent et ses enfants.
<br clear="all">

.l-main-section
:marked
  ## Directives
figure
  img(src="/resources/images/devguide/architecture/directive.png" alt="Parent child" style="float:left; width:150px; margin-left:-40px;margin-right:10px" )
:marked
  Angular templates are *dynamic*. When Angular renders them, it transforms the DOM
  according to the instructions given by **directives**.

  Les templates Angular sont *dynamiques*. Lorsque Angular les affiche, il transforme le DOM
  par rapport aux instructions fournies par les **directives**.

  A directive is a class with directive metadata. In !{_Lang} we apply the `@Directive` !{_decorator}
  to attach metadata to the class.

  Une directive est une classe contenant des métadonnées de directive. En !{_Lang} nous appliquons le décorateur `@Directive`
  pour attacher les métadonnées à la classe.
<br clear="all">
:marked
  We already met one form of directive: the component. A component is a *directive-with-a-template*;
  a `@Component` !{_decorator} is actually a `@Directive` !{_decorator} extended with template-oriented features.

  Nous avons déjà rencontré une forme de directive&nbsp;: le composant. Un composant est une *directive avec un template*&nbsp;;
  le décorateur `@Component` est en fait un décorateur `@Directive` enrichi de fonctionnalités de gestion de template.

.l-sub-section
  :marked
    While **a component is technically a directive**,
    components are so distinctive and central to Angular applications that we chose
    to separate components from directives in this architectural overview.

    Bien que **les composants soient techniquement des directives**,
    ils ont un rôle tellement central et particulier dans les applications Angular que nous avons choisi
    de les séparer des directives dans cette présentation architecturale.
:marked
  Two *other* kinds of directives exist: _structural_ and _attribute_ directives.

  Il existe deux *autres* types de directives&nbsp;: les directives _structurelles_ et les directives _d'attribut_.

  They tend to appear within an element tag as attributes do,
  sometimes by name but more often as the target of an assignment or a binding.

  Elles ont tendances à apparaître dans une balise comme les attributs,
  parfois sous la forme d'un nom mais le plus souvent comme cible d'une affectation ou d'une liaison de données.

  **Structural** directives alter layout by adding, removing, and replacing elements in DOM.

  Les directives **structurelles** modifient la structure de la page en ajoutant, supprimant ou remplaçant des éléments dans le DOM.

  Our [example](#templates) template uses two built-in structural directives:

  Notre [exemple](#templates) de template utilise deux directives structurelles natives&nbsp;:

+makeExcerpt('app/hero-list.component.1.html', 'structural')

:marked
  * [`*ngFor`](displaying-data.html#ngFor) tells Angular to stamp out one `<li>` per hero in the `heroes` list.

  * [`*ngFor`](displaying-data.html#ngFor) indique à Angular d'afficher un `<li>` par héros dans la liste `heroes`.

  * [`*ngIf`](displaying-data.html#ngIf) includes the `HeroDetail` component only if a selected hero exists.

  * [`*ngIf`](displaying-data.html#ngIf) inclue le composant `HeroDetail` seulement si un héros a été sélectionné.

block dart-bool
  //- N/A

:marked
  **Attribute** directives alter the appearance or behavior of an existing element.
  In templates they look like regular HTML attributes, hence the name.

  Les directives **d'attribut** altèrent l'apparence ou le comportement d'un élément existant.
  Dans les templates elles ressemblent à des attributs HTML normaux, mise à part leur nom.

  The `ngModel` directive, which implements two-way data binding, is
  an example of an attribute directive. `ngModel` modifies the behavior of
  an existing element (typically an `<input>`)
  by setting its display value property and responding to change events.

  La directive `ngModel` qui implémente la liaison de données bidirectionnelle, est
  un exemple de directive d'attribut. `ngModel` modifie le comportement
  d'un élément existant (typiquement un `<input>`)
  en renseignant sa valeur affichée et en répondant aux évènements de saisies.

+makeExcerpt('app/hero-detail.component.html', 'ngModel')
:marked
  Angular ships with a small number of other directives that either alter the layout structure
  (for example, [ngSwitch](template-syntax.html#ngSwitch))
  or modify aspects of DOM elements and components
  (for example, [ngStyle](template-syntax.html#ngStyle) and [ngClass](template-syntax.html#ngClass)).

  Angular s'accompagne d'un petit nombre de directives natives qui modifient soit la structure de la page
  (par exemple [ngSwitch](template-syntax.html#ngSwitch))
  ou l'aspect des éléments du DOM ou des composants
  (par exemple [ngStyle](template-syntax.html#ngStyle) et [ngClass](template-syntax.html#ngClass)).

  Of course, we can also write our own directives. Components such as
  `HeroListComponent` are one kind of custom directive.
  <!-- PENDING: link to where to learn more about other kinds! -->

  Nous pouvons bien sûr écrire nos propres directives. Les composants comme
  le `HeroListComponent` sont un type de directives personnalisées.
  <!-- PENDING: link to where to learn more about other kinds! -->

.l-main-section
:marked
  ## Services
figure
  img(src="/resources/images/devguide/architecture/service.png" alt="Service" style="float:left; margin-left:-40px;margin-right:10px" )
:marked
  _Service_ is a broad category encompassing any value, function, or feature that our application needs.

  Les _services_ appartiennent à une vaste catégorie qui englobe toute valeur, fonction ou fonctionnalité dont notre application a besoin.

  Almost anything can be a service.
  A service is typically a class with a narrow, well-defined purpose. It should do something specific and do it well.

  Tout peut être un service.
  Un service est typiquement une classe avec un but bien défini. Il doit faire quelque chose de spécifique et le faire bien.
<br clear="all">
:marked
  Examples include:

  Par exemple&nbsp;:

  * logging service

  * un service de traces

  * data service

  * un service de données

  * message bus

  * un bus de messages

  * tax calculator

  * un calculateur de TVA

  * application configuration

  * la configuration de l'application

  There is nothing specifically _Angular_ about services. Angular itself has no definition of a service.
  There is no service base class, and no place to register a service.

  Il n'y a rien de particulier dans _Angular_ pour les services. Angular lui même n'a pas de définition de service.
  Il n'y a pas de classe de base et de mécanisme de déclarations de services.

  Yet services are fundamental to any Angular application. Our components are big consumers of services.

  Mais pourtant les services sont fondamentaux dans les applications Angular. Nos composants sont de gros consommateurs de services.

  Here's an example of a service class that logs to the browser console

  Ci-dessous un exemple de classe de service qui affiche des messages dans la console du navigateur

+makeExcerpt('app/logger.service.ts', 'class')

:marked
  Here's a `HeroService` that fetches heroes and returns them in a resolved !{_PromiseLinked}.
  The `HeroService` depends on the `Logger` service and another `BackendService` that handles the server communication grunt work.

  Voici le `HeroService` qui récupère les héros et les retourne sous la forme d'une !{_PromiseLinked}.
  Le `HeroService` dépend du service `Logger` et du `BackendService` qui gère la communication avec le serveur.

+makeExcerpt('app/hero.service.ts', 'class')

:marked
  Services are everywhere.

  Les services sont partout.

  We prefer our component classes lean. Our components don't fetch data from the server,
  they don't validate user input, and they don't log directly to the console.
  They delegate such tasks to services.

  Nous préférons alléger nos classes de composants. Nos composants ne récupèrent pas des données du serveur,
  ils ne valident pas les données saisies par l'utilisateur, et ils n'affichent pas directement des messages dans la console.
  Ils délèguent toutes ces taches à des services.

  A component's job is to enable the user experience and nothing more. It mediates between the view (rendered by the template)
  and the application logic (which often includes some notion of a _model_).
  A good component presents properties and methods for data binding.
  It delegates everything nontrivial to services.

  Le travail d'un composant est d'améliorer l'expérience utilisateur et rien de plus. Il fait l'intermédiaire entre la vue (affichée dans le template)
  et la logique applicative (qui comporte souvent des notions de  _modèles_).
  Un bon composant expose des propriétés et des méthodes pour la liaison de données.
  Il délègue le reste à des services.

  Angular doesn't *enforce* these principles.
  It won't complain if we write a "kitchen sink" component with 3000 lines.

  Angular ne vous **oblige** pas à utiliser ces concepts.
  Il ne vous empêchera pas d'écrire un composant fourre-tout de 3000 lignes.

  Angular does help us *follow* these principles by making it easy to factor our
  application logic into services and make those services available to components through *dependency injection*.

  Angular nous encourage à *suivre* ces principes en nous facilitant la mise en place de la
  logique applicative dans des services et en rendant ces services disponibles pour nos composants grâce à  *l'injection de dépendances*.

.l-main-section
:marked
  ## Dependency injection

  ## Injection de dépendances
figure
  img(src="/resources/images/devguide/architecture/dependency-injection.png" alt="Service" style="float:left; width:200px; margin-left:-40px;margin-right:10px" )
:marked
  _Dependency injection_ is a way to supply a new instance of a class
  with the fully-formed dependencies it requires. Most dependencies are services.
  Angular uses dependency injection to provide new components with the services they need.

  L'_injection de dépendances_ permet de fournir une nouvelle instance de classe
  avec toutes les dépendances dont elle a besoin. La plupart des dépendances sont des services.
  Angular utilise l'injection de dépendances pour fournir de nouveaux composants avec les services qu'ils utilisent.
  <br clear="all">
:marked
  Angular can tell which services a component needs by looking at the types of its constructor parameters.
  For example, the constructor of our `HeroListComponent` needs a `HeroService`:

  Angular peut savoir de quels services un composant aura besoin en regardant les types des paramètres du constructeur.
  Par exemple, le constructeur de notre `HeroListComponent` nécessite un `HeroService`&nbsp;:
+makeExcerpt('app/hero-list.component.ts (constructor)', 'ctor')

:marked
  When Angular creates a component, it first asks an **injector** for
  the services that the component requires.

  Lorsque Angular crée le composant, il demande d'abord à **l'injecteur** les services dont il a besoin.

  An injector maintains a container of service instances that it has previously created.
  If a requested service instance is not in the container, the injector makes one and adds it to the container
  before returning the service to Angular.
  When all requested services have been resolved and returned,
  Angular can call the component's constructor with those services as arguments.
  This is what we mean by *dependency injection*.

  Un injecteur possède une réserve d'instances de services créées précédemment.
  Si une instance demandée n'est pas dans la réserve, l'injecteur l'instancie et l'y ajoute avant
  de fournir le service à Angular.
  Lorsque tous les services demandés ont été résolus et fournis,
  Angular peut appeler le constructeur du composant en passant ces services en arguments.
  C'est ce que nous appelons *l'injection de dépendances*.

  The process of `HeroService` injection looks a bit like this:

  Le processus d'injection du `HeroService`ressemble un peu à ça&nbsp;:
figure
  img(src="/resources/images/devguide/architecture/injector-injects.png" alt="Service" )
:marked
  If the injector doesn't have a `HeroService`, how does it know how to make one?

  Si l'injecteur ne connait pas le `HeroService`, comment sait-il le construire&nbsp;?

  In brief, we must have previously registered a **provider** of the `HeroService` with the injector.
  A provider is something that can create or return a service, typically  the service class itself.

  En bref, nous avons précédemment enregistré un **fournisseur** du `HeroService` avec l'injecteur.
  Un fournisseur est capable de créer ou de retourner un service, typiquement c'est souvent la classe de service elle même.

  We can register providers at any level of the application component tree.
  We often do so at the root when we bootstrap the application so that
  the same instance of a service is available everywhere.

  Nous pouvons enregistrer les fournisseurs à n'importe quel niveau de notre arbre de composants.
  Nous le faisons souvent au niveau le plus haut à l'initialisation de l'application pour que
  une même instance de service soit disponible partout dans l'application.

+makeExcerpt('app/main.ts', 'bootstrap')

:marked
  Alternatively, we might register at a component level, in the providers property of the `@Component` metadata:

  Nous pouvons également procéder à l'enregistrement au niveau d'un composant, dans la propriété providers de la métadonnée `@Component`&nbsp;:

+makeExcerpt('app/hero-list.component.ts', 'providers')

:marked
  Registering at a component level means we get a new instance of the
  service with each new instance of that component.

  Un enregistrement au niveau du composant signifie que nous aurons une nouvelle instance du service
  pour chaque nouvelle instance du composant.

  <!-- We've vastly oversimplified dependency injection for this overview.
  The full story is in the [Dependency Injection](dependency-injection.html) chapter. -->

  <!-- Nous simplifions énormément l'injection de dépendances pour cette présentation.
  L'explication complète est disponible dans le chapitre [Injection de dépendances](dependency-injection.html). -->

  Points to remember about dependency injection:

  Ce qu'il faut retenir sur l'injection de dépendances&nbsp;:

  * Dependency injection is wired into the Angular framework and used everywhere.

  * L'injection de dépendances est intégrée dans le framework Angular et est utilisée partout.

  * The *injector* is the main mechanism.

  * L'*injecteur* en est le principal acteur.

    * An injector maintains a *container* of service instances that it created.

    * Un injecteur maintient une *collection* d'instances de services préalablement créées.

    * An injector can create a new service instance from a *provider*.

    * Un injecteur peut créer une nouvelle instance de service à l'aide d'un *fournisseur*.

  * A *provider* is a recipe for creating a service.

  * Un *fournisseur* permet de créer un service.

  * We register *providers* with injectors.

  * Nous associons les *fournisseurs* aux injecteurs.

.l-main-section
:marked
  ## Wrap up

  ## Résumé

  We've learned just a bit about the eight main building blocks of an Angular application:

  Nous en avons appris un peu plus sur les huit principaux constituants d'une application Angular&nbsp;:

  1. [Modules](#modules)
  1. [Les modules](#modules)

  1. [Components](#components)
  1. [Les composants](#components)

  1. [Templates](#templates)
  1. [Les templates](#templates)

  1. [Metadata](#metadata)
  1. [Les métadonnées](#metadata)

  1. [Data binding](#data-binding)
  1. [La liaison de données](#data-binding)

  1. [Directives](#directives)
  1. [Les directives](#directives)

  1. [Services](#services)
  1. [Les services](#services)

  1. [Dependency injection](#dependency-injection)
  1. [L'injection de dépendances](#dependency-injection)

  That's a foundation for everything else in an Angular application,
  and it's more than enough to get going.
  But it doesn't include everything we'll need or want to know.

  Ce sont les bases pour tout le reste dans une application Angular,
  et nous en savons plus qu'assez pour avancer.
  Mais nous devons et voulons en apprendre plus.

  Here is a brief, alphabetical list of other important Angular features and services.
  Most of them are covered in this Developers Guide (or soon will be).

  Vous trouverez ci-dessous une liste de fonctionnalités importantes d'Angular classées par ordre alphabétique.
  La plupart sont déjà couvertes dans le Guide du Développeur (ou le seront bientôt).

  > [**Animations**](animations.html): The animation library makes it easy for developers to animate component behavior
  without deep knowledge of animation techniques or CSS.

  > [**Les animations**](animations.html): La librairie d'animation permet au développeur d'animer facilement un composant
  sans connaissance approfondie des techniques d'animations CSS.

  > **Bootstrap**: A method to configure and launch the root application component.

  > **Démarrage**: Une méthode pour configurer et lancer le composant principal de notre application.

  > **Change detection**: Learn how Angular decides that a component property value has changed and
  when to update the screen.
  Learn how it uses **zones** to intercept asynchronous activity and run its change detection strategies.

  > **La détection des changements**: Apprenez comment Angular décide que la valeur d'une propriété de composant a changé
  et que la page doit être mise à jour.
  Apprenez comment utiliser les **zones** pour intercepter des traitements asynchrones et activer le processus de détection du changement.

  > **Component router**: With the component Router service, users can navigate a multi-screen application
  in a familiar web browsing style using URLs.

  > **Le composant routeur**: A l'aide du composant Routeur, l'utilisateur peut naviguer dans une application multipages
    dans un environnement web familier en utilisant les URL.

  > **Events**: The DOM raises events. So can components and services. Angular offers mechanisms for
  publishing and subscribing to events.

  > **Les événements**: Le DOM génère des événements. Les composants et services le peuvent également. Angular offre un mécanisme
  pour lancer et écouter des événements

  > [**Forms**](forms.html): Support complex data entry scenarios with HTML-based validation and dirty checking.

  > [**Les formulaires**](forms.html): Mettez en place des scénarios complexes de validations de données en vous appuyant sur le HTML.

  > [**HTTP**](server-communication.html): Communicate with a server to get data, save data, and invoke server-side actions with an HTTP client.

  > [**HTTP**](server-communication.html): Communiquez avec un serveur pour récupérer et sauvegarder des données, déclencher des actions coté serveur à l'aide d'un client HTPP.

  > [**Lifecycle hooks**](lifecycle-hooks.html): We can tap into key moments in the lifetime of a component, from its creation to its destruction,
  by implementing the lifecycle hook interfaces.

  > [**Les méthodes du cycle de vie**](lifecycle-hooks.html): Nous pouvons intervenir à des moments clés dans la vie d'un composant, de sa création à sa destruction,
  en implémentant les méthodes du cycle de vie.

  > [**Pipes**](pipes.html): Services that transform values for display.
  We can put pipes in our templates to improve the user experience. Consider
  this `currency` pipe expression:

  > [**Les pipes**](pipes.html): Ce sont des services qui transforment une valeur avant de l'afficher.
  Nous pouvons utiliser des pipes dans nos templates pour améliore l'expérience utilisateur.
  Considérez l'expression suivante utilisant le pipe `currency`:

<div style="margin-left:40px">
code-example().
  price | currency:'USD':true
</div>
:marked
  > It displays a price of "42.33" as `$42.33`.

  > On affiche alors un prix de "42.33" sous la forme `$42.33`.

  > [**Router**](router.html): Navigate from page to page within the client
    application and never leave the browser.

  > [**Le Routeur**](router.html): Naviguez de page en page dans votre application
    sans jamais rafraichir le navigateur.

  > [**Testing**](testing.html): Angular provides a
  [testing library](https://pub.dartlang.org/packages/angular2_testing)
  to run unit tests on our application parts as they interact with the Angular framework.

  > [**Le test**](testing.html): Angular fournit une
  [librarie de test](https://pub.dartlang.org/packages/angular2_testing)
  pour exécuter des tests unitaires sur une partie de notre application en interaction directe avec le framework Angular.

