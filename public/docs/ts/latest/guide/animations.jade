include ../_util-fns

:marked
  Le mouvement est un aspect important du design d'applications web modernes.
  Nous voulons des interfaces utilisateur qui aient des transitions fluides entre leurs états, et des animations stimulantes qui attirent l'attention au bon endroit.
  Des animations bien conçues peuvent rendre une UI non seulement plus fun mais aussi plus facile à utiliser.

  Le système d'animations d'Angular nous fournit ce dont nous avons besoin pour créer le genre d'animation que nous voulons.
  Nous pouvons construire des animations qui s'exécutent avec le même niveau de performance native auquel les animations en pur CSS nous ont habitués.
  Mais nous pouvons également avoir notre logique d'animation étroitement intégrée au reste du code de notre application,
  où elles pourront facilement être déclenchées et contrôlées.

.alert.is-helpful
  :marked
    Les animations Angular sont construites sur la base de l'[API d'animations web standard](https://w3c.github.io/web-animations/)
    et elles tournent nativement sur les [navigateurs qui la supportent](http://caniuse.com/#feat=web-animation).

    Pour les autres navigateurs, un *polyfill* est nécessaire.
    Téléchargez [`web-animations.min.js` ici](https://github.com/web-animations/web-animations-js) et ajoutez-le à votre page.

    Un polyfill plus léger maintenu par l'équipe Angular est en préparation.

:marked
  # Table des Matières
  
  * [Démarrage Rapide&nbsp;: Transitions Entre Deux États](#example-transitioning-between-states)
  * [États et Transitions](#states-and-transitions)
  * [Exemple&nbsp;: Entrer et Sortir](#example-entering-and-leaving)
  * [Exemple&nbsp;: Entrer et Sortir depuis des États Différents](#example-entering-and-leaving-from-different-states)
  * [Propriétés et Unités Animables](#animatable-properties-and-units)
  * [Calcul Automatique de Propriété](#automatic-property-calculation)
  * [Timing d'Animation](#animation-timing)
  * [Animations à Plusieurs Étapes avec les Keyframes](#multi-step-animations-with-keyframes)
  * [Groupes d'Animation Parallèles](#parallel-animation-groups)

.l-sub-section
  :marked
      Les exemples référencés dans ce chapitre sont disponibles via un [exemple en ligne](/resources/live-examples/animations/ts/plnkr.html).

a(id="example-transitioning-between-states")
.l-main-section
:marked
  ## Démarrage Rapide&nbsp;: Transitions Entre Deux États
figure
  img(src="/resources/images/devguide/animations/animation_basic_click.gif" alt="Une animation de transition simple" align="right" style="width:220px;margin-left:20px" )
:marked
  Construisons une animation simple qui fait transiter un élément entre deux états déterminés par un attribut du modèle.

  Les animations sont définies dans les métadonnées `@Component`.
  Avant de pouvoir en ajouter, nous devons importer quelques fonctions spécifiques aux animations&nbsp;:

+makeExample('animations/ts/app/hero-list-basic.component.ts', 'imports')(format=".")

:marked
  Avec ça nous pouvont maintenant définir un déclencheur d'animation (*trigger*) appelé `heroState` dans les métadonnées du composant.
  Il comporte des transitions animées entre deux états&nbsp;: `active` et `inactive`.
  Quand un héros est actif, on affiche l'élément avec une taille un peu plus grande et une couleur plus claire.

+makeExample('animations/ts/app/hero-list-basic.component.ts', 'animationdef')(format=".")

.alert.is-helpful
  :marked
    Dans cet exemple, nous définissons des styles d'animation (couleur et transformation) directement à l'intérieur des métadonnées d'animation.
    Dans une version d'Angular à venir, il sera possible d'aller récupérer les styles depuis le fichier CSS du composant à la place.

:marked
  Nous avons maintenant une animation définie mais elle n'est utilisée nulle part.
  Nous pouvons changer cela en la rattachant à un ou plusieurs éléments dans le template du composant en utilisant la syntaxe "`@triggerName`"&nbsp;

+makeExample('animations/ts/app/hero-list-basic.component.ts', 'template')(format=".")

:marked
  Nous avons appliqué ici un déclencheur d'animation à chaque élément répété par un `ngFor`.
  Chacun des éléments répétés sera animé indépendamment.
  Nous rattachons la valeur de l'attribut à l'expression `hero.state`.
  Nous prévoyons qu'elle sera toujours `inactive` ou `active`, étant donné que ce sont les valeurs pour lesquelles nous avons définis des états d'animation. 

  Avec cette configuration, une transition animée a lieu à chaque fois qu'un héros change d'état&nbsp;!
  Voici l'implémentation complète du composant&nbsp;:

+makeExample('animations/ts/app/hero-list-basic.component.ts')

:marked
  ## États et Transitions

  Les animations Angular sont définies en termes d'**états** logiques et de **transitions** entre états.

  Un état d'animation est une chaîne de caractères que nous définissons dans le code de notre application.
  Dans l'exemple ci-dessus nous avons utilisé les états `'active'` et `'inactive'` en se basant sur l'état logique des objets de type héros.
  La source de l'état peut être un simple attribut d'objet comme dans ce cas, ou bien une valeur calculée dans une méthode.
  L'important est que nous pouvons la lire dans le template du composant.

  On peut définir des *styles* pour chaque état de l'animation&nbsp;:

+makeExample('animations/ts/app/hero-list-basic.component.ts', 'states')(format=".")

:marked
  Ces définitions d'états spécifient les *style finaux* de chaque état.
  Ils sont appliqués à l'élément une fois qu'il a effectué la transition vers cet état, et resteront *tant qu'il sera dans cet état*.
  En ce sens, nous définissons plus que des animations.
  Nous définissons en réalité les styles qu'aura l'élément dans différents états.

  Une fois que nous avons des états, nous pouvons définir des transitions entre ces états.
  Chaque transition contrôle le timing du passage entre un ensemble de styles vers le suivant&nbsp;:

+makeExample('animations/ts/app/hero-list-basic.component.ts', 'transitions')(format=".")

figure.image-display
  img(src="/resources/images/devguide/animations/ng_animate_transitions_inactive_active.png" alt="Avec les animations Angular on définit les états et les transitions entre ces états" width="400")

:marked
  Si nous avons la même configuration temporelle pour différentes transitions, elles peuvent être combinées en une seule définition de `transition`&nbsp;:

+makeExample('animations/ts/app/hero-list-combined-transitions.component.ts', 'transitions')(format=".")

:marked
  Quand la configuration temporelle est la même dans les deux sens d'une transition, comme c'est le cas dans l'exemple précédent, 
  on peut utiliser la syntaxe raccourcie `<=>`&nbsp;:

+makeExample('animations/ts/app/hero-list-twoway.component.ts', 'transitions')(format=".")

:marked
  Parfois nous avons des styles que nous voulons appliquer pendant une animation mais ne pas garder une fois l'animation terminée.
  On peut définir ces styles directement dans la `transition`.
  Dans cet exemple, l'élément reçoit un ensemble de styles immédiatement et est ensuite animé vers le suivant.
  Lorsque la transition sera terminée, aucun de ces styles ne sera gardé car ils ne sont pas définis dans un `state`.

+makeExample('animations/ts/app/hero-list-inline-styles.component.ts', 'transitions')(format=".")

:marked
  ### L'état générique `*`

  L'état générique `*` (wildcard) correspond à *n'importe quel* état d'animation.
  Il est utile pour définir des styles et transitions qui doivent s'appliquer quelque soit l'état courant de l'animation.
  Par exemple&nbsp;:

  * La transition `active => *` s'applique lorsque l'état de l'élément change de `active` à n'importe quoi d'autre.
  * La transition `* => *` s'applique lorsque n'importe quel changement d'état a lieu.

figure.image-display
  img(src="/resources/images/devguide/animations/ng_animate_transitions_inactive_active_wildcards.png" alt="L'état générique peut être utilisé pour correspondre à plusieurs transitions différentes à la fois" width="400")


:marked
  ### L'état vide `void`

  Il existe un état particulier appelé `void` qui peut être appliqué à n'importe quelle animation.
  Il s'applique lorsque l'élément n'est *pas* rattaché à une vue.
  Cela peut arriver parce qu'il n'a pas encore été ajouté ou parce qu'il a été supprimé.
  L'état vide est utile pour définir des animations d'entrée ("enter") et de sortie ("leave").
  
  Par exemple la transition `* => void` s'applique lorsque l'élément quitte la vue, quelque soit l'état dans lequel il était avant de sortir.

figure.image-display
  img(src="/resources/images/devguide/animations/ng_animate_transitions_void_in.png" alt="L'état vide peut être utilisé pour les animations d'entrée et de sortie" width="400")

:marked
  L'état générique `*` correspond aussi à l'état vide `void`.

  ## Exemple&nbsp;: Entrer et Sortir
figure
  img(src="/resources/images/devguide/animations/animation_enter_leave.gif" alt="Animations d'entrée et de sortie" align="right" style="width:250px;" )
:marked
  En utilisant les état `void` et `*` nous pouvons définir des transitions qui animent l'entrée et la sortie des éléments&nbsp;:

  * Entrer&nbsp;: `void => *`
  * Sortir&nbsp;: `* => void`

+makeExample('animations/ts/app/hero-list-enter-leave.component.ts', 'animationdef')(format=".")

:marked
  Notons que dans ce cas les styles appliqués à l'état vide se trouvent directement dans les définitions de transition, et non dans une définition `state(void)` séparée.
  Nous faisons cela car nous voulons des transitions différentes pour l'entrée et la sortie&nbsp;:
  l'élement entre par la gauche et sort par la droite.

  ## Exemple&nbsp;: Entrer et Sortir depuis des États Différents
figure
  img(src="/resources/images/devguide/animations/animation_enter_leave_states.gif" alt="Animations d'entrée et de sortie combinées avec des animations d'état" align="right" style="width:200px" )
:marked
  Nous pouvons également combiner cette animation avec les animations de changement d'état précédentes en utilisant l'état du héros comme état de l'animation.
  Cela nous permettra de configurer différentes transitions pour entrer et sortir en se basant sur l'état courant du héros&nbsp;:

  * Entrée d'un héros inactif&nbsp; `void => inactive`
  * Entrée d'un héros actif&nbsp; `void => active`
  * Sortie d'un héros inactif&nbsp; `inactive => void`
  * Sortie d'un héros actif&nbsp; `active => void`

  Nous avons maintenant un contrôle précis sur chaque transition&nbsp;:

figure.image-display
  img(src="/resources/images/devguide/animations/ng_animate_transitions_inactive_active_void.png" alt="Cet exemple montre les transitions entre états actif, inactif et vide" width="400")


+makeExample('animations/ts/app/hero-list-enter-leave-states.component.ts', 'animationdef')(format=".")

:marked
  ## Propriétés et Unités Animables

  Parce que le support des animations Angular est construit sur la base des Animations Web, 
  nous pouvons animer n'importe quelle propriété considérée *animable* par le navigateur.
  Cela inclut la position, taille, transformation, couleur, bordure et beaucoup d'autres.
  Le W3C maintient [une liste des propriétés animables](https://www.w3.org/TR/css3-transitions/#animatable-properties).

  Pour les propriétés de position qui ont une valeur numérique, on peut définir une unité en fournissant 
  la valeur sour la forme d'une chaîne de caractères avec le suffixe adapté&nbsp;:

  * `'50px'`
  * `'3em'`
  * `'100%'`

  Pour la plupart des propriétés de taille on peut également définir un nombre qui sera interprété comme étant en pixels&nbsp;:
  
  * `50` revient à écrire `'50px'`

  ## Calcul Automatique de Propriété
figure
  img(src="/resources/images/devguide/animations/animation_auto.gif" alt="Animation avec calcul automatique de hauteur" align="right" style="width:220px;margin-left:20px" )
:marked
  Parfois la valeur d'une propriété de taille que l'on veut animer n'est pas connue avant l'exécution.
  Par exemple, il est assez courant que des éléments aient une hauteur et une largeur dépendantes de leur contenu et de la taille de l'écran.
  Ces propriétés sont souvent difficiles à animer en CSS.

  Avec Angular, nous pouvons utiliser une propriété spéciale `*` dans ces situations.
  Cela signifie que la valeur de cette propriété sera calculée à l'exécution puis intégrée dans l'animation.

  L'animation de sortie dans cet exemple prend la hauteur que l'élément aura avant de sortir et anime depuis cette taille jusqu'à zéro&nbsp;:

+makeExample('animations/ts/app/hero-list-auto.component.ts', 'animationdef')(format=".")

:marked
  ## Timing d'Animation

  Il existe trois propriétés de timing que nous pouvons régler pour toute transition animée&nbsp;:
  la durée, le délai et la function d'*easing*.
  Elles sont toutes combinées en une seule chaîne de caractères de timing de transition.

  ### Durée

  La durée contrôle le temps que l'animation met pour s'exécuter du début à la fin.
  On peut définir une durée sous trois formes&nbsp;:

  * Un simple nombre, en millisecondes&nbsp;: `100`
  * Une chaîne de caractères, en millisecondes&nbsp;: `'100ms'`
  * Une chaîne de caractères, en secondes&nbsp;: `'0.1s'`

  ### Délai

  Le délai contrôle le temps d'attente entre le moment où l'animation est déclenchée et celui où elle débute réellement. 
  On peut le définir en l'ajoutant à la même chaîne juste après la durée.
  Il a les mêmes options de formatage que la durée&nbsp;:
  
  * Attendre 100ms puis s'exécuter en 200ms&nbsp;: `'0.2s 100ms'`

  ### Easing

  La [fonction d'easing](http://easings.net/) contrôle la façon dont l'animation accélère et décélère au cours de son exécution.
  Par exemple, utiliser une fonction `ease-in` signifie que l'animation démarre relativement lentement mais prend ensuite de la vitesse au fur et à mesure de son avancement.
  On peut contrôler l'easing en ajoutant une *troisième* valeur à la chaîne après la durée et le délai 
  (ou une *seconde* valeur si aucun délai n'est défini)&nbsp;:

  * Attendre 100ms puis s'exécuter en 200ms, avec easing&nbsp;: `'0.2s 100ms ease-out'`
  * S'exécuter en 200ms, avec easing&nbsp;: `'0.2s ease-in-out'`

figure
  img(src="/resources/images/devguide/animations/animation_timings.gif" alt="Animations avec des timings spécifiques" align="right" style="width:220px;margin-left:20px" )
:marked
  ### Exemple

  Voici quelques exemples de timings personnalisés en action.
  Les animations d'entrée et de sortie durent toutes les deux 200 millisecondes mais ont des easings différents.
  La sortie démarre avec un léger délai&nbsp;:

+makeExample('animations/ts/app/hero-list-timings.component.ts', 'animationdef')(format=".")

:marked
  ## Animations à Plusieurs Étapes avec les Keyframes
figure
  img(src="/resources/images/devguide/animations/animation_multistep.gif" alt="Animations avec du rebond implémenté avec des keyframes" align="right" style="width:220px;margin-left:20px" )
:marked
  Avec les *keyframes* d'animation nous pouvons aller au-delà d'une simple transition entre deux ensembles de styles
  vers une animation plus complexe qui passe par un ou plusieurs styles intermédiaires.

  Pour chaque keyframe, nous pouvons spécifier un décalage (*offset*) qui définit à quel stade de l'animation ce keyframe est appliqué.
  L'offset est un nombre entre zéro, qui marque le début de l'animation, et un, qui en marque la fin.

  Dans cet exemple nous ajoutons du "rebond" à nos animations d'entrée et de sortie grâce aux keyframes&nbsp;: 

+makeExample('animations/ts/app/hero-list-multistep.component.ts', 'animationdef')(format=".")

:marked
  Notons que les offsets ne sont *pas* définis en terme de temps absolu.
  Ce sont des mesures relatives de 0 à 1.
  La timeline finale de l'animation sera basée sur la combinaison des offsets de keyframes, de la durée, du délai et de l'easing.

  Définir des offsets pour les keyframes est optionnel.
  S'ils sont omis, des offsets uniformément espacés sont automatiquement assignés.
  Par exemple, trois keyframes sans offsets prédéfinis recevront les offsets `0`, `0.5`, et `1`.

:marked
  ## Groupes d'Animation Parallèle
figure
  img(src="/resources/images/devguide/animations/animation_groups.gif" alt="Animations parallèles avec des timings différents, implémentées avec des groupes" align="right" style="width:220px;margin-left:20px" )
:marked
  Nous avons déjà vu comment animer plusieurs propriétés de style simultanément&nbsp;:
  il suffit de toutes les mettre dans la même définition de `style()`&nbsp;!

  Mais nous pourrions aussi vouloir configurer des *timings* différents pour des animations ayant lieu en parallèle.
  Par exemple, nous pourrions vouloir animer deux propriété CSS mais en utilisant un easing différent pour chacune d'elles.

  Pour cela nous pouvons utiliser les *groupes* d'animation.
  Dans cet exemple nous utilisons les groupes pour l'entrée et la sortie afin de pouvoir utiliser deux configurations temporelles différentes.
  Les deux sont appliquées au même élément en parallèle, mais s'exécutent indépendamment l'une de l'autre&nbsp;:

+makeExample('animations/ts/app/hero-list-groups.component.ts', 'animationdef')(format=".")

:marked
  Un groupe anime la transformation et la largeur de l'élément.
  L'autre anime son opacité.
